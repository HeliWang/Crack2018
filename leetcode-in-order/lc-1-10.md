# 2 sum

Given an array of integers, return **indices **of the two numbers such that they add up to a specific target.

You may assume that each input would have **exactly **one solution, and you may not use the same element twice.

Example:

```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

Idea:

```
暴力算法是O(n^2)，我们用一个hashmap来减少一次遍历
```

Solution:

```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> mp;
    vector<int> res;
    mp[nums[0]] = 0;
    for (int i = 1; i < nums.size(); i++) {
        if (mp.count(target - nums[i]) > 0) {
            vector<int> res1({mp[target - nums[i]], i});
            return res1;
        }
        mp[nums[i]] = i;
    }
    return res;
}
```

Similar Questions:

[Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/), [3 Sum, ](https://leetcode.com/problems/3sum/description/)[4 Sum](https://leetcode.com/problems/4sum/description/), [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

